"""
Created on Fri Feb  7 09:10:47 2020

@author: emilyk
"""
import SimpleITK as sitk
import os
import fnmatch
import numpy as np
from scipy.stats import pearsonr
dirname = os.path.abspath(os.path.curdir)
from segmentationVolume import segVol
from utils import IoU
from hausdorffDistance import hausdorff_dist
from thresholdOutput import thresholdCube
np.set_printoptions(threshold=1200, suppress=True)
 
#Import validation output
data = []
for fl in os.listdir(dirname + '/ValidationOutput/fold0'):
    if fnmatch.fnmatch(fl, '*.mhd'):
        data.append(fl)
        
#Import real/reference data
data_real = []
for fl in os.listdir(dirname + '/OriginalData'):
    if fnmatch.fnmatch(fl,''):
        data_real.append(fl)

vol_calc = []
vol_real = []
j_index = []
haus_dist = []

for i in range(len(data)):
     
    #Processing for validation output 
    image_calc = (sitk.ReadImage(dirname + '/ValidationOutput/fold0/'+ str(data[i])))
    image_calc_arr = (sitk.GetArrayFromImage(image_calc))
    seg_calc_arr = (thresholdCube(image_calc_arr))
    seg_calc = (sitk.GetImageFromArray(seg_calc_arr))
    
    #Processing for original input
    image_real_arr = (np.load(dirname + '/OriginalData/' + str(data[i][:-4]) + '.npy'))
    image_real = (sitk.GetImageFromArray(image_real_arr))
    seg_real_arr = (np.load(dirname + '/OriginalData/Mask_' + str(data[i][:-4]) + '.npy'))
    seg_real = (sitk.GetImageFromArray(seg_real_arr))
     
    #Volume Calculation
    vol_calc.append(float(segVol(image_calc, seg_calc)))
    vol_real.append(float(segVol(image_real, seg_real)))
    
    #Jaccard index and Hausdorff Distance Calculation
    j_index.append(1-(IoU(seg_calc_arr, seg_real_arr)))
    haus_dist.append(hausdorff_dist(seg_calc_arr, seg_real_arr, image_calc, image_real))

#Commented code was originally intended to compute performance metrics only for slices where original data had data. 
#This was intended to remove some of the additional nodules our network picked up.
#    count = 0
#    for t in range(len(seg_real_arr)):
#        if (np.sum(seg_real_arr[t]) > 0 and count == 0):
#            start = t
#            count = 1
#        if (np.sum(seg_real_arr[t]) == 0 and count == 1):
#            end = t
#            break
#    j_index.append(IoU(seg_calc_arr[start:end], seg_real_arr[start:end]))
#    vol_calc.append(float(segVol(image_calc[start:end], seg_calc[start:end])))
#    vol_real.append(float(segVol(image_real, seg_real)))
#    haus_dist.append(hausdorff_dist(seg_calc_arr[start:end], seg_real_arr[start:end], image_calc[start:end], image_real[start:end]))

#Final Performance Calculations (Done by normalizing each metric by maximum case)
mean_j = 1 - ((np.mean(j_index/np.max(j_index))))
mean_h = 1 - (np.mean((haus_dist/np.max(haus_dist))))
vol_calc = np.array(vol_calc)
vol_real = np.array(vol_real)
prsn = 1 - (pearsonr(vol_calc, vol_real)[0])
bias = (np.sum(abs(vol_calc - vol_real)))/len(vol_calc)
max_diff = np.max(abs(vol_calc - vol_real))
stdev = np.std(abs(vol_calc - vol_real))
print('pearsonr=',prsn, 'bias=',(1-(bias/max_diff)), 'standarddev=',(1-(stdev/max_diff)), 'jaccard=',mean_j, 'hausdorff=',mean_h)
print((prsn + (1-(bias/max_diff)) + (1-(stdev/max_diff)) + mean_j + mean_h)/5) 
